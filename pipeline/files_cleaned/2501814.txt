кэш микропроцессора — кэш (сверхоперативная память), используемый микропроцессором компьютера для уменьшения среднего времени доступа к компьютерной памяти. является одним из верхних уровней иерархии памяти. кэш использует небольшую, очень быструю память (обычно типа sram), которая хранит копии часто используемых данных из основной памяти. если большая часть запросов в память будет обрабатываться кэшем, средняя задержка обращения к памяти будет приближаться к задержкам работы кэша.
когда процессору нужно обратиться в память для чтения или записи данных, он сначала проверяет, доступна ли их копия в кэше. в случае успеха проверки процессор производит операцию, используя кэш, что значительно быстрее использования более медленной основной памяти. подробнее о задержках памяти см. латентность sdram: tcas, trcd, trp, tras.
данные между кэшем и памятью передаются блоками фиксированного размера, также называемыми линиями кэша (англ. cache line) или блоками кэша.
большинство современных микропроцессоров для компьютеров и серверов имеет как минимум три независимых кэша: кэш инструкций для ускорения загрузки машинного кода, кэш данных для ускорения чтения и записи данных, и буфер ассоциативной трансляции (tlb) для ускорения трансляции виртуальных (логических) адресов в физические, как для инструкций, так и для данных. кэш данных часто реализуется в виде многоуровневого кэша (l1, l2, l3, l4).
увеличение размера кэш-памяти может положительно влиять на производительность почти всех приложений, хотя в некоторых случаях эффект незначителен. работа кэш-памяти обычно прозрачна для программиста, однако для её эффективного использования в некоторых случаях применяются специальные алгоритмические приёмы, изменяющие порядок обхода данных в озу или повышающие их локальность (например, при блочном умножении матриц).


== принцип работы ==
данный раздел описывает типичный кэш данных и некоторые виды кэшей инструкций; буфер ассоциативной трансляции (tlb) может быть устроен сложнее, а кэш инструкций — проще. на диаграмме справа изображены основная и кэш-память. каждая строка — группа ячеек памяти содержит данные, организованные в кэш-линии. размер каждой кэш-линии может различаться в разных процессорах, но для большинства x86-процессоров он составляет 64 байта. размер кэш-линии обычно больше размера данных, к которому возможен доступ из одной машинной команды (типичные размеры от 1 до 16 байт). каждая группа данных в памяти размером в 1 кэш-линию имеет порядковый номер. для основной памяти этот номер является адресом памяти с отброшенными младшими битами. в кэше каждой кэш-линии дополнительно ставится в соответствие тег, который является адресом продублированных в этой кэш-линии данных в основной памяти.
при доступе процессора в память сначала производится проверка, хранит ли кэш запрашиваемые из памяти данные. для этого производится сравнение адреса запроса со значениями всех тегов кэша, в которых эти данные могут храниться. случай совпадения с тегом какой-либо кэш-линии называется попаданием в кэш (англ. cache hit), обратный же случай называется кэш-промахом (англ. cache miss). попадание в кэш позволяет процессору немедленно произвести чтение или запись данных в кэш-линии с совпавшим тегом. отношение количества попаданий в кэш к общему количеству запросов к памяти называют рейтингом попаданий (англ. hit rate), оно является мерой эффективности кэша для выбранного алгоритма или программы.
в случае промаха в кэше выделяется новая запись, в тег которой записывается адрес текущего запроса, а в саму кэш-линию — данные из памяти после их прочтения либо данные для записи в память.  промахи по чтению задерживают исполнение, поскольку они требуют запроса данных в более медленной основной памяти. промахи по записи могут не давать задержку, поскольку записываемые данные сразу могут быть сохранены в кэше, а запись их в основную память можно произвести в фоновом режиме. работа кэшей инструкций во многом похожа на вышеприведенный алгоритм работы кэша данных, но для инструкций выполняются только запросы на чтение. кэши инструкций и данных могут быть разделены для увеличения производительности (принцип, используемый в гарвардской архитектуре) или объединены для упрощения аппаратной реализации.
для добавления данных в кэш после кэш-промаха может потребоваться вытеснение (англ. evict) ранее записанных данных. для выбора замещаемой строки кэша используется эвристика, называемая политика замещения (англ. replacement policy). основной проблемой алгоритма является предсказание, какая строка вероятнее всего не потребуется для последующих операций. качественные предсказания сложны, и аппаратные кэши используют простые правила, такие, как lru. пометка некоторых областей памяти как некэшируемых (англ. non cacheable) улучшает производительность за счёт запрета кэширования редко используемых данных. промахи для такой памяти не создают копии данных в кэше.
при записи данных в кэш должен существовать определённый момент времени, когда они будут записаны в основную память. это время контролируется политикой записи (англ. write policy). для кэшей со сквозной записью (англ. write-through) любая запись в кэш приводит к немедленной записи в память. другой тип кэшей, обратная запись англ. write-back (иногда также называемый copy-back), откладывает запись на более позднее время. в таких кэшах отслеживается состояние кэш-линеек ещё не сброшенных в память (пометка битом «грязный» англ. dirty). запись в память производится при вытеснении подобной строки из кэша. таким образом, промах в кэше, использующем политику обратной записи, может потребовать двух операций доступа в память, один для сброса состояния старой строки и другой — для чтения новых данных.
существуют также смешанные политики. кэш может быть со сквозной записью (англ. write-through), но для уменьшения количества транзакций на шине записи могут временно помещаться в очередь и объединяться друг с другом.
данные в основной памяти могут изменяться не только процессором, но и периферией, использующей прямой доступ к памяти, или другими процессорами в многопроцессорной системе. изменение данных приводит к устареванию их копии в кэше (состояние stale). в другой реализации, когда один процессор изменяет данные в кэше, копии этих данных в кэшах других процессоров будут помечены как stale. для поддержания содержимого нескольких кэшей в актуальном состоянии используется специальный протокол поддержки когерентности.


=== структура записи в кэше ===
типичная структура записи в кэше

блок данных (кэш-линия) содержит непосредственную копию данных из основной памяти. бит актуальности означает, что данная запись содержит актуальную (самую свежую) копию.
структура адреса

адрес памяти разделяется (от старших бит к младшим) на тег, индекс и смещение. длина поля индекса равна ⌈log2⁡(cache_rows)⌉{\displaystyle \lceil \log _{2}(cache\_rows)\rceil } бит и соответствует ряду (строке) кэша, используемой для записи. длина смещения равна ⌈log2⁡(data_blocks)⌉{\displaystyle \lceil \log _{2}(data\_blocks)\rceil }. 


=== ассоциативность ===
ассоциативность является компромиссом. проверка большего числа записей требует больше затрат энергии, площади чипа, и, потенциально, времени. если бы существовало 10 мест, в которые алгоритм вытеснения мог бы отобразить место в памяти, тогда проверка наличия этого места в кэше потребовала бы просмотра 10 записей в кэше. с другой стороны, кэши с высокой ассоциативностью подвержены меньшему количеству промахов (см. ниже «конфликтующие промахи») и процессор тратит меньше времени на чтения из медленной основной памяти.
существует эмпирическое наблюдение, что удвоение ассоциативности (от прямого отображения — к 2-канальной или от 2- — к 4-канальной) имеет примерно такое же влияние на интенсивность попаданий (hit rate), что и удвоение размера кэша. увеличение ассоциативности свыше 4 каналов приносит меньший эффект для уменьшения количества промахов (miss rate) и обычно производится по другим причинам, например, из-за пересечения виртуальных адресов.
в порядке ухудшения (увеличения длительности проверки на попадание) и улучшения (уменьшения количества промахов):

кэш прямого отображения (англ. direct mapped cache) — наилучшее время попадания и, соответственно, лучший вариант для больших кэшей;
2-канальный множественно-ассоциативный кэш англ. 2-way set associative cache;
2-канальный skewed ассоциативный кэш (англ. «the best tradeoff for …. caches whose sizes are in the range 4k-8k bytes» — andré seznec);
4-канальный множественно-ассоциативный кэш (англ. 4-way set associative cache);
полностью ассоциативный кэш, англ. fully associative cache — наилучший (самый низкий) процент промахов (miss rate) и лучший вариант при чрезвычайно высоких затратах при промахе (miss penalty).
			
			
		
		
			
			
		
		
			
			
		


==== псевдоассоциативный кэш ====
псевдоассоциативный кэш - это тип кэш-памяти, который использует комбинацию прямого и наборного способов поиска кэш-блока. псевдоассоциативный кэш разделяет кэш-память на несколько частей, называемых наборами. каждый набор содержит несколько кэш-линий или блоков данных. когда происходит обращение к памяти, хэш-адрес элемента вычисляется, и затем проверяются все линии в соответствующем наборе памяти. кэш-память с псевдоассоциативной организацией обеспечивает компромисс между простотой проекта и эффективностью поиска данных.


=== виды промахов ===
промах по чтению из кэша инструкций. обычно дает очень большую задержку, поскольку процессор не может продолжать исполнение программы (по крайней мере, текущего потока исполнения) и вынужден простаивать в ожидании загрузки инструкции из памяти.
промах по чтению из кэша данных. обычно дает меньшую задержку, поскольку инструкции, не зависящие от запрошенных данных, могут продолжать исполняться, пока запрос обрабатывается в основной памяти. после получения данных из памяти можно продолжать исполнение зависимых инструкций.
промах по записи в кэш данных. обычно дает наименьшую задержку, поскольку запись может быть поставлена в очередь и последующие инструкции практически не ограничены в своих возможностях. процессор может продолжать свою работу, кроме случаев промаха по записи с полностью заполненной очередью.


=== категории промахов (three cs) ===
compulsory misses — промахи, вызванные первым упоминанием запрошенного адреса. размеры кэшей и их ассоциативность не влияют на количество данных промахов. предвыборка (prefetching), как программная, так и аппаратная, может помочь, так же, как и увеличение размера кэш-линии (в качестве вида аппаратной предвыборки). такие промахи иногда называются «холодными».
capacity misses — промахи, вызванные исключительно конечным размером кэша, происходящие вне зависимости от степени ассоциативности или размера кэш-линии. график таких промахов относительно размера кэша может дать некоторую меру временной локальности (temporal locality) некоторого набора запросов в память. стоит заметить, что не существует понятия полного кэша, пустого кэша или почти полного кэша, так как кэши процессора почти все время имеют кэш-линии в занятом состоянии, и, значит, практически каждое заведение новой линии потребует гашения уже занятой.
conflict misses — промахи, вызванные конфликтом. их можно избежать, если бы кэш не вытеснил запись ранее. можно дополнительно разделить на промахи, вызванные отображением (конкретным значением ассоциативности) и промахи замещения, которые вызваны конкретным алгоритмом выбора записей для замещения.


=== трансляция адресов ===

большая часть процессоров общего назначения реализует какой-либо вариант виртуальной памяти. кратко говоря, каждая программа, исполняющаяся на машине, видит собственное упрощенное адресное пространство, содержащее код и данные только этой программы. любая программа использует своё виртуальное адресное пространство вне зависимости от его местоположения в физической памяти.
наличие виртуальной памяти требует от процессора проведения трансляции виртуальных (математических) адресов, используемых программой, в физические адреса, соответствующие реальному местоположению в озу. часть процессора, проводящая это преобразование, называется устройство управления памятью (mmu). для ускорения трансляций в mmu добавлен кэш недавно использованных отображений (соответствий виртуальных и физических адресов), называемый translation lookaside buffer (tlb).
для дальнейшего описания важны три особенности процесса трансляции адресов:

задержка: физический адрес будет получен от mmu только спустя некоторое время, вплоть до нескольких тактов, после подачи на вход mmu виртуального адреса с генератора адресов.
эффект наложения: несколько виртуальных адресов могут соответствовать одному физическому. в большинстве процессоров гарантируется, что все записи по физическому адресу будут совершены в порядке, заданном программой. для выполнения этого свойства требуется проверка, что только один экземпляр копии данных с физического адреса находится в данный момент в кэше.
единица отображения: виртуальное адресное пространство разбито на страницы — блоки памяти фиксированного размера, начинающиеся с адресов, кратных их размеру. например, 4 гб адресного пространства можно разделить на 1048576 страниц по 4 кб, для каждой из которых возможно независимое соответствие физическим страницам. в современных процессорах часто поддерживается использование одновременно нескольких размеров страниц, например, 4 кб и 2 мб для x86-64, а в некоторых современных amd-процессорах ещё и 1 гб.важно также заметить, что первые системы виртуальной памяти были очень медленными, потому что они требовали проверки таблицы страниц (хранимой в основной озу) перед любым программным обращением в память. без использования кэширования для отображений такие системы уменьшают скорость работы с памятью примерно в 2 раза. поэтому использование tlb очень важно и иногда его добавление в процессоры предшествовало появлению обычных кэшей данных и инструкций.
по отношению к виртуальной адресации кэши данных и инструкций могут быть поделены на 4 типа. адреса в кэшах используются для двух разных целей: индексирования и тегирования.

physically indexed, physically tagged (pipt) — физически индексируемые и физически тегируемые. такие кэши просты и избегают проблем с наложением (aliasing), но они медленны, так как перед обращением в кэш требуется запрос физического адреса в tlb. этот запрос может вызвать промах в tlb и дополнительное обращение в основную память перед тем, как наличие данных будет проверено в кэше.
virtually indexed, virtually tagged (vivt) — виртуально индексируемые и виртуально тегируемые. и для тегирования, и для индекса используется виртуальный адрес. благодаря этому проверки наличия данных в кэше происходят быстрее, не требуя обращения к mmu. однако возникает проблема наложения, когда несколько виртуальных адресов соответствуют одному и тому же физическому. в этом случае данные будут закэшированы дважды, что сильно усложняет поддержку когерентности. другой проблемой являются омонимы, ситуации, когда один и тот же виртуальный адрес (например, в разных процессах) отображается в различные физические адреса. становится невозможным различить такие отображения исключительно по виртуальному индексу. возможные решения: сброс кэша при переключении между задачами (context switch), требование непересечения адресных пространств процессов, тегирование виртуальных адресов идентификатором адресного пространства (address space id, asid) или использование физических тегов. также возникает проблема при изменении отображения виртуальных адресов в физические, что требует сброса кэш-линий, для которых изменилось отображение.
virtually indexed, physically tagged (vipt) — виртуально индексируемые и физически тегируемые. для индекса используется виртуальный адрес, а для тега — физический. преимуществом над первым типом является меньшая задержка, поскольку можно искать кэш-линию одновременно с трансляцией адресов в tlb, однако сравнение тега задерживается до получения физического адреса. преимуществом над вторым типом является обнаружение омонимов (homonyms), так как тег содержит физический адрес. для данного типа требуется больше бит для тега, поскольку индексные биты используют иной тип адресации.
physically indexed, virtually tagged — физически индексируемые и виртуально тегированные кэши считаются бесполезными и маргинальными и представляют исключительно академический интерес.скорость этих действий (задержка загрузки из памяти) критически важна для производительности процессоров, и поэтому большинство современных l1-кэшей является виртуально индексируемым, что как минимум позволяет блоку mmu производить запрос в tlb одновременно с запросом данных из кэш-памяти.


=== виртуальное тегирование и механизм vhints ===
но виртуальная индексация не является лучшим выбором для других уровней кэша. стоимость обнаружения пересечения виртуальных адресов (aliasing) растет с увеличением размера кэша и, в результате, большинство реализаций l2 и более дальних от процессора уровней кэша использует индексирование по физическим адресам.
достаточно длительное время кэши использовали для тегов как физические, так и виртуальные адреса, хотя виртуальное тегирование в настоящее время встречается очень редко. если tlb-запрос заканчивается раньше запроса в кэш-память, физический адрес будет доступен для сравнения с тегом к моменту, когда это будет необходимо, и, следовательно, виртуальное тегирование не потребуется. большие кэши чаще тегируются физическими адресами, и только небольшие быстродействующие кэши используют для тегов виртуальные адреса. в современных процессорах общего назначения, виртуальное тегирование заменено на механизм vhints, описанный далее.


==== виртуальное индексирование и пересечения виртуальных адресов ====


==== проблема гомонимов и синонимов ====


==== расцвечивание страниц ====


=== иерархия кэшей в современных микропроцессорах ===
большинство современных процессоров содержит в себе несколько взаимодействующих кэшей.


==== специализированные кэши ====
суперскалярные цпу осуществляют доступ к памяти из нескольких этапов конвейера: чтение инструкции (instruction fetch), трансляция виртуальных адресов в физические, чтение данных (data fetch). очевидным решением является использование различных физических кэшей для каждого из этих случаев, чтобы не было борьбы за доступ к одному из физических ресурсов с разных стадий конвейера. таким образом, наличие конвейера обычно приводит к наличию, по крайней мере, трёх раздельных кэшей: кэш инструкций, кэш трансляций tlb и кэш данных, каждый из которых специализирован на своей задаче.
конвейерные процессоры, использующие раздельные кэши для данных и для инструкций (такие процессоры сейчас повсеместны), называются процессорами с гарвардской архитектурой. изначально данный термин применялся для компьютеров, у которых инструкции и данные разделены полностью и хранятся в различных устройствах памяти. однако такое полное разделение не оказалось популярным, и большинство современных компьютеров имеет одно устройство основной памяти, поэтому могут считаться машинами с архитектурой фон неймана.


==== многоуровневые кэши ====
одной из проблем является фундаментальная проблема баланса между задержками кэша и интенсивностью попаданий. большие кэши имеют более высокий процент попаданий, но, вместе с тем, и большую задержку. чтобы ослабить противоречие между этими двумя параметрами, большинство компьютеров использует несколько уровней кэша, когда после маленьких и быстрых кэшей находятся более медленные большие кэши (в настоящий момент — суммарно до 3 уровней в иерархии кэшей).
в единичных случаях реализуют 4 уровня кэш-памяти.
многоуровневые кэши обычно работают в последовательности от меньших кэшей к большим. сначала происходит проверка наименьшего и наибыстрейшего кэша первого уровня (l1), в случае попадания процессор продолжает работу на высокой скорости. если меньший кэш дал промах, проверяется следующий, чуть больший и более медленный кэш второго уровня (l2), и так далее, пока не будет запроса к основному озу.
по мере того, как разница задержек между озу и быстрейшим кэшем увеличивается, в некоторых процессорах увеличивают количество уровней кэша (в некоторых — до 3х уровней на кристалле). к примеру, процессор alpha 21164 в 1995 году имел накристалльный кэш 3го уровня в 96 кб; ibm power4 в 2001 году имел до четырёх кэшей l3 по 32 мб на отдельных кристаллах, используемых совместно несколькими ядрами; itanium 2 в 2003 году имел 6 мб кэш l3 на кристалле; xeon mp под кодом «tulsa» в 2006 году — 16 мб кэша l3 на кристалле, общий на 2 ядра; phenom ii в 2008 году — до 6 мб универсального l3 кэша; intel core i7 в 2008 году — 8 мб накристалльного кэша l3, являющимся инклюзивным и разделяемым между всеми ядрами. польза от кэша l3 зависит от характера обращений программы в память.
наконец, с другой стороны иерархии памяти находится регистровый файл самого микропроцессора, который можно рассматривать как небольшой и самый быстрый кэш в системе со специальными свойствами (например, статическое планирование компилятором при распределении регистров, когда он располагает данные из озу на регистр). подробнее см. loop nest optimization. регистровые файлы также могут иметь иерархию: cray-1 (в 1976 году) имел 8 адресных «a»-регистров и 8 скалярных «s»-регистров общего назначения. также машина содержала набор из 64 адресных «b» и 64 скалярных «t» регистров, обращение к которым было дольше, но все же значительно быстрее основной озу. эти регистры были введены по причине отсутствия в машине кэша данных (хотя кэш команд в машине имелся)

			
			
		
		
			
			
		
		
			
			
		


==== эксклюзивность (исключительность) и инклюзивность ====
для многоуровневых кэшей требуется делать новые архитектурные решения.
например, в некотором процессоре могут потребовать, чтобы все данные, хранящиеся в кэше l1, хранились также и в кэше l2. такие пары кэшей называют строго инклюзивными (англ. inclusive). другие процессоры (например, amd athlon) могут не иметь подобного требования, тогда кэши называются эксклюзивными (исключительными) — данные могут быть либо в l1, либо в l2 кэше, но никогда не могут быть одновременно в обоих.
до сих пор другим процессорам (таким, как pentium ii, pentium iii, и pentium 4) не требуются, чтобы данные в кэше первого уровня также размещались в кэше второго уровня, тем не менее, они продолжают так делать. нет никакого универсального общепринятого имени для этой промежуточной политики, хотя часто используется термин главным образом инклюзивно (англ. mainly inclusive).
преимущество исключительных кэшей в том, что они хранят больше данных. это преимущество больше, когда исключительный кэш l1 сопоставим по размеру с кэшэм l2, и меньше, если кэш l2 во много раз больше, чем кэш l1. когда l1 пропускает и l2 получает доступ в случае попадания, строка кэша попадания в l2 обменивается со строкой в l1.


==== victim cache ====
victim cache или victim buffer) (дословно кэш жертв) — это небольшой специализированный кэш, хранящий те кэш-линии, которые были недавно вытеснены из основного кэша микропроцессора при их замещении. данный кэш располагается между основным кэшем и его англ. refill path. обычно кэш жертв является полностью ассоциативным и служит для уменьшения количества конфликтных промахов (conflict miss). многие часто используемые программы не требуют полного ассоциативного отображения для всех попыток доступа к памяти. по статистике только небольшая доля обращений к памяти потребует высокой степени ассоциативности. именно для таких обращений служит кэш жертв, предоставляющий высокую ассоциативность для подобных редких запросов. был предложен norman jouppi (dec) в 1990.
размер такого кэша может составлять от 4 до 16 кэш-линий.


==== кэш трасс ====
одним из наиболее экстремальных случаев специализации кэшей можно считать кэш трасс (англ. trace cache), используемый в процессорах intel pentium 4.
кэш трасс — это механизм для увеличения пропускной способности загрузки инструкций и для уменьшения тепловыделения (в случае pentium 4) за счёт хранения декодированных трасс инструкций. таким образом этот кэш исключал работу декодера при повторном исполнении недавно выполнявшегося кода.
одной из ранних публикаций о кэше трасс была статья коллектива авторов (eric rotenberg, steve bennett и jim smith), вышедшая в 1996 году под названием «trace cache: a low latency approach to high bandwidth instruction fetching.» (кэш трасс: низколатентный подход для обеспечения высокой пропускной способности загрузки инструкций).
кэш трасс сохраняет декодированные инструкции либо после их декодирования, либо после окончания их исполнения. обобщая, инструкции добавляются в кэш трасс в группах, представляющих собой либо базовые блоки, либо динамические трассы. динамическая трасса (путь исполнения) состоит только из инструкций, результаты которых были значимы (использовались впоследствии), и удаляет инструкции, которые находятся в неисполняющихся ветвях, кроме того, динамическая трасса может быть объединением нескольких базовых блоков. такая особенность позволяет устройству подгрузки инструкций в процессоре загружать сразу несколько базовых блоков без необходимости заботиться о наличии ветвлений в потоке исполнения.
линии трасс хранятся в кэше трасс по адресам, соответствующим счётчику инструкций первой машинной команды из трассы, к которым добавлен набор признаков предсказания ветвлений. такая адресация позволяет хранить различные трассы исполнения, начинающиеся с одного адреса, но представляющие различные ситуации по результату предсказания ветвлений. на стадии подгрузки инструкции (instruction fetch) конвейера инструкций для проверки попадания в кэш трасс используется как текущий счётчик инструкций (program counter), так и состояние предсказателя ветвлений. если попадание свершилось, линия трассы непосредственно подается на конвейер без необходимости опрашивать обычный кэш (l2) или основное озу. кэш трасс подает машинные команды на вход конвейера, пока не кончится линия трассы, либо пока не произойдет ошибка предсказания в конвейере. в случае промаха кэш трасс начинает строить следующую линию трассы, загружая машинный код из кэша или из памяти.
похожие кэши трасс использовались в pentium 4 для хранения декодированных микроопераций и микрокода, реализующего сложные x86-инструкции. smith, rotenberg and bennett’s paper см полный текст работы в citeseer.


== реализации ==


=== история ===
в ранние годы микропроцессорных технологий доступ в память был лишь немного медленнее доступа к процессорным регистрам. но с 1980-х разрыв в производительности между процессорами и памятью стал нарастать. микропроцессоры совершенствовались быстрее, чем память, особенно в плане частоты функционирования, таким образом, память становилась узким местом при достижении полной производительности от системы. хотя было технически возможным иметь основную память столь же быстрой, как и цпу, был выбран более экономичный путь: использовать избыточное количество низкоскоростной памяти, но ввести в систему небольшую, но быструю кэш-память, для смягчения разрыва в производительности. в итоге получили на порядок большие объёмы памяти, примерно за ту же цену и с небольшими потерями общей производительности.
чтение данных из кэша для современных процессоров обычно занимает более одного такта. время исполнения программ является чувствительным к задержкам чтения из кэша данных первого уровня. много усилий разработчиков, а также мощности и площади кристалла при создании процессора отводится для ускорения работы кэшей.
простейшим кэшем является виртуально индексируемый кэш прямого отображения. виртуальный адрес подсчитывается при помощи сумматора, соответствующая часть адреса выделяется и используется для индексирования sram, который вернет загружаемые данные. данные могут быть выровнены по байтовым границам в байтовом сдвигателе и затем переданы следующей операции. при таком чтении не требуется какая-либо проверка тегов, фактически нет даже необходимости считывать тег. на более поздних стадиях конвейера, перед окончанием исполнения инструкции чтения, потребуется чтение тега и его сравнение с виртуальным адресом, чтобы удостовериться, что произошло попадание в кэш. если же был промах, потребуется чтение из памяти либо более медленного кэша с дальнейшим обновлением рассматриваемого кэша и перезапуском конвейера.
ассоциативный кэш более сложен, потому что некоторый вариант тега нужно считать для определения, какую часть кэша выбрать. кэш n-way set-associative первого уровня обычно считывает одновременно все n возможных тегов и n данных параллельно, затем проводит сравнение тегов с адресом и выбор данных, ассоциированных с совпавшим тегом. кэши 2-го уровня в целях экономии энерговыделения иногда выполняют сначала чтение тегов, и только затем чтение одного элемента данных из sram-данных.

диаграмма справа должна показать, как происходит использование различных частей адреса. бит 31 адреса является наиболее значимым битом (старшим), бит 0 — наименее значащим битом (младшим). на диаграмме показаны две sram, индексация и мультиплексирование для 4 кб, 2-way set-associative, виртуально индексированного и виртуально тегированного кэша с 64байтными блоками, 32битной шириной чтения и 32битным виртуальным адресом.
поскольку кэш имеет размер 4 кб и линии размером 64 байта, в нём хранится 64 линии, и мы можем считать за два раза из тега sram, который содержит 32 столбца, каждый из которых содержит пару 21-битных тегов.
хотя может быть использована любая функция виртуальной адресации битов 31 по 6, чтобы индексировать тег и данные sram, проще всего воспользоваться младшими разрядами.
так же, потому что объём кэша составляет 4 кб и имеет четырёхбайтный путь для чтения, и чтение производится по двум путями для каждого доступа, данные sram составляют 512 рядов шириной 8 байт.
более современный кэш, возможно, был бы 16-килобайтным, четырёхпутным, набор-ассоциативным, виртуально индексируемым, виртуально попадаемым и физически помечаемым (тегом), с 32-битными строками, 32-битной шириной шины чтения и 36-битным физическим адресованием. рекуррентное соотношение пути чтения для такого кэша выглядит очень схоже с рассмотренными выше. вместо тегов читаются виртуальные попадания? (англ. vhits), и снова производится соответствие подмножества виртуальному адресу. позже, в конвейере, виртуальный адрес переводится в физический адрес tlb, и производится чтение физического тега (только одно, так как виртуальное попадание поставляет путь для чтения кэша). в конце физический адрес сравнивается с физическим тегом, чтобы определить, произошло ли попадание.
некоторые процессоры sparc имели ускоренные на несколько задержек затвора (англ. gate delay) l1 кэши за счёт использования sram-декодеров вместо сумматора виртуальных адресов. подробнее см. en:sum addressed decoder.


=== в x86 ===
когда микропроцессоры x86 достигли частот в 20 и более мегагерц (начиная с intel 80386), для увеличения производительности в них было добавлено небольшое количество быстрой кэш-памяти. это было необходимо из-за того, что используемая как системная озу dram имела значительные задержки (до 120 нс), и требовала такты для обновления. кэш был построен на базе более дорогой, но значительно более быстрой sram, которая в те времена имела задержки 15-20 нс. ранние кэши были внешними по отношению к процессору и часто располагались на материнской плате как 8 или 9 микросхем в корпусах dip, расположенные в сокетах для возможности увеличения или уменьшения размера кэша. некоторые версии процессора i386 поддерживали от 16 до 64 кб внешнего кэша.
с выходом процессора intel 80486 8 кб кэша было интегрировано непосредственно на кристалл микропроцессора. этот кэш был назван l1 (первого уровня, англ. level 1), чтобы отличать его от более медленного кэша на материнской плате, названного l2 (второго уровня, англ. level 2). последние были значительно больше, вплоть до 256 кб.
в дальнейшем случаи отделения кэша производились, лишь исходя из соображений маркетинговой политики, например, в микропроцессоре celeron, построенном на ядре pentium ii.
в микропроцессоре pentium используется раздельный кэш, команд и данных. буфер трансляции адресов (tlb) преобразует адрес в озу в соответствующий адрес в кэше. кэш данных pentium использует метод обратной записи (англ. write-back), который позволяет модифицировать данные в кэше без дополнительного обращения к оперативной памяти (данные записываются в озу только при удалении из кэша) и протокол mesi (modified, exclusive, shared, invalid), который обеспечивает когерентность данных в кэшах процессоров и в озу при работе в мультипроцессорной системе.
каждый из раздельных кэшей, данных и команд, микропроцессора pentium mmx имеет объём 16 кб и содержит два порта, по одному для каждого исполнительного конвейера. кэш данных имеет буфер трансляции адресов (tlb).
следующий вариант реализации кэшей в x86 появился в pentium pro, в котором кэш второго уровня (объединённый для данных и команд, размером 256—512 кб) размещён в одном корпусе с процессором и кэшем первого уровня, размером 8 кб, раздельным для данных и команд, и поднял его частоту до частоты ядра. позже кэш второго уровня стал размещаться на том же кристалле, что и процессор.
двойная независимая шина (англ. dual independent bus) — новая архитектура кэш-памяти, использует разные шины для соединения процессорного ядра с основной оперативной памятью. кэш первого уровня двухпортовый, неблокирующий, поддерживает одну операцию загрузки и одну операцию записи за такт. работает на тактовой частоте процессора. за такт передаётся 64 бита.
в микропроцессоре pentium ii кэш первого уровня увеличен — 16 кб для данных и 16 кб для команд. для кэша второго уровня используется bsram, расположенная на одной с процессором плате в картридже s.e.c. для установки в slot 1.
с ростом популярности многоядерных процессоров на кристалл стали добавлять кэши третьего уровня, названные l3. этот уровень кэша может быть общим для нескольких ядер и реализовывать эффективное взаимодействие между ядрами. его объём обычно больше суммарного объёма кэшей всех подключенных к нему ядер и может достигать 16 мб.
популярным кэш на материнской плате оставался до эры выхода pentium mmx и вышел из употребления с введением sdram и ростом разницы между частотой шины процессора и частотой ядра процессора: кэш на материнской плате стал лишь немногим быстрее основной озу.


==== пример кэша (процессорное ядро к8) ====

приведена схема кэшей ядра микропроцессоров amd k8, на которой видны как специализированные кэши, так и их многоуровневость.
ядро использует четыре различных специализированных кэша: кэш инструкций, tlb инструкций, tlb данных и кэш данных:

кэш инструкций состоит из 64-байтных блоков, являющихся копией основной памяти, и может подгружать до 16 байтов за такт. каждый байт в этом кэше хранится в 10 битах, а не в 8, причём в дополнительных битах отмечены границы инструкций (т. о. кэш проводит частичное преддекодирование). для проверки целостности данных используется лишь контроль четности, а не ecc, так как бит четности занимает меньше места, а в случае сбоя повреждённые данные можно обновить правильной версией из памяти.
tlb инструкций содержит копии записей из таблицы страниц. на каждый запрос чтения команд требуется трансляция математических адресов в физические. записи о трансляции бывают 4- и 8-байтными, и tlb разбит на 2 части, соответственно одна для 4 кб отображений и другая для 2 и 4 мб отображений (большие страницы). такое разбиение упрощает схемы полностью ассоциативного поиска в каждой из частей. ос и приложения могут использовать отображения различного размера для частей виртуального адресного пространства.
tlb данных является сдвоенным, и оба буфера содержат одинаковый набор записей. их сдвоенность позволяет производить каждый такт трансляцию для двух запросов к данным одновременно. так же, как и tlb инструкций, этот буфер разделен между записями двух видов.
кэш данных содержит 64-байтные копии фрагментов памяти. он разделен на 8 банков (банок), каждый содержит по 8 килобайт данных. кэш позволяет производить по два запроса к 8-байтовым данным каждый такт, при условии, что запросы будут обработаны различными банками. теговые структуры в кэше продублированы, так как каждый 64-байтный блок распределен по всем 8 банкам. если совершается 2 запроса в один такт, они работают с собственной копией теговой информации.также в этом ядре используются многоуровневые кэши: двухуровневые tlb инструкций и данных (на втором уровне хранятся лишь записи о 4-кб отображениях), и кэш второго уровня (l2), унифицированный для работы как с кэшами данных и инструкций 1го уровня, так и для различных tlb. кэш l2 является эксклюзивным для l1 данных и l1 инструкций, то есть каждый кэшированный 8-байтовый фрагмент может находиться либо в l1 инструкций, либо в l1 данных, либо в l2. исключением могут быть лишь байты, составляющие записи pte, которые могут находиться одновременно в tlb и в кэше данных во время обработки виртуального отображения со стороны ос. в таком случае ос отвечает за своевременный сброс tlb после обновления записей трансляции.


=== dec alpha ===
в микропроцессоре dec alpha 21164 (выпущенном в ноябре 1995 года с тактовой частотой 333 мгц) кэш первого уровня может поддерживать некоторое количество (до 21) необработанных промахов. имеется шестиэлементный файл адресов необработанных промахов (англ. miss address file, maf), каждый элемент которого содержит адрес и регистр для загрузки при промахе (если адреса промаха принадлежат одной строке кэша, то в maf они рассматриваются как один элемент).
помимо раздельных кэшей l1 со сквозной записью, на кристалле процессора расположены частично-ассоциативный кэш l2 с обратной записью и контроллер кэша l3, работающего как в синхронном, так и в асинхронном режиме.
в выпущенном в марте 1997 года dec alpha 21164pc внешний кэш второго уровня; объём кэша команд увеличен до 16 кб.
в микропроцессоре dec alpha 21264 нет кэша второго уровня (контроллер которого, тем не менее, размещается на кристалле), но кэш первого уровня увеличен до 128 кб (по 64 кб для кэша команд и кэша данных соответственно).


=== pa-risc ===
разработка hewlett-packard для научных и инженерных вычислений pa-8000 содержит буфер переупорядочивания адресов (англ. arb), отслеживающий все команды загрузки/сохранения, который позволяет сократить задержку адресования внешней кэш-памяти данных и команд, которая в данном процессоре может иметь объём до 4 мб. тем не менее, даже эффективное управление внешним кэшем при помощи высокоскоростных линий управления и предвыборки данных и команд из основной памяти в кэш не скомпенсировало невысокую скорость и высокую стоимость.
устранить указанные недостатки удалось в pa-8500, в котором за счёт техпроцесса 0,25 мкм удалось добавить на кристалл 512 кб кэша команд и 1 мб кэша данных.


=== powerpc ===
построенный на гарвардской архитектуре powerpc 620 содержит два встроенных кэша, ёмкостью 32 кб каждый, которые имеют собственные блоки управления памятью (англ. mmu) и функционируют независимо друг от друга. команды и адреса переходов кэшируются в кэше btac (англ. branch-target adress cache).
шинный интерфейс процессора включает полную реализацию поддержки кэша второго уровня (объёмом до 128 мб, работающем на частоте процессора либо вдвое/вчетверо меньшей), и для управления работой внешнего кэша не требует дополнительных тактов. реализована комбинация сквозной и обратной записи а также поддержка протокола mesi.


=== mips ===
своя специфика у кэша l1, применяемого в ra-10000, — каждая команда в кэше снабжена дополнительным четырёхбитным тегом, который используется в дальнейшем декодировании и классификации команды.


=== текущие разработки ===


== примечания ==


== см. также ==
когерентность кэша
кэш


== ссылки ==
memory part 2: cpu caches статья на lwn.net (автор ulrich drepper) с детальным описанием кэшей
8-way set-associative кэш написанный на vhdl